// Prisma schema for VertaAI
// Knowledge Drift Agent for Engineering Ops

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ======================================================================
// NEW MODELS (Phase 1: Workspace-based multi-tenancy)
// These coexist with Organization model for gradual migration
// ======================================================================

// Workspaces (new multi-tenant model - replaces Organization)
model Workspace {
  id         String @id @default(uuid())
  name       String
  slug       String @unique
  ownerEmail String @map("owner_email")

  // Ownership config (for owner resolution)
  ownershipSourceRanking String[] @default(["pagerduty", "codeowners", "manual"]) @map("ownership_source_ranking")
  defaultOwnerType       String   @default("slack_channel") @map("default_owner_type")
  defaultOwnerRef        String   @default("#engineering") @map("default_owner_ref")

  // Notification policy (confidence-based routing)
  // UPDATED: Aligned with Phase 2 systematic fixes (was 0.70/0.55, now 0.98/0.40)
  highConfidenceThreshold   Float   @default(0.98) @map("high_confidence_threshold")
  mediumConfidenceThreshold Float   @default(0.40) @map("medium_confidence_threshold")
  digestChannel             String? @map("digest_channel")

  // Workspace policy for doc resolution (per spec Section 1.1 + Section 7)
  primaryDocRequired        Boolean  @default(false) @map("primary_doc_required") // If true, fail if no primary doc mapping exists
  allowPrLinkOverride       Boolean  @default(true) @map("allow_pr_link_override") // Allow PR links to override mappings
  allowSearchSuggestMapping Boolean  @default(false) @map("allow_search_suggest_mapping") // Allow search-based suggestions (P2)
  minConfidenceForSuggest   Float    @default(0.6) @map("min_confidence_for_suggest") // Min confidence for search suggest
  allowedConfluenceSpaces   String[] @default([]) @map("allowed_confluence_spaces") // Space key allowlist (empty = allow all)

  // Workflow preferences (Phase 5 - Settings page)
  // JSON structure: { enabledDriftTypes: string[], enabledInputSources: string[], enabledOutputTargets: string[], outputTargetPriority: string[] }
  workflowPreferences Json @default("{}") @map("workflow_preferences")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  integrations          Integration[]
  signalEvents          SignalEvent[]
  driftPlans            DriftPlan[]
  planRuns              PlanRun[] // NEW: Gap #6 - Plan execution tracking
  driftCandidates       DriftCandidate[]
  patchProposals        PatchProposal[]
  docMappingsV2         DocMappingV2[]
  ownerMappings         OwnerMapping[]
  auditEvents           AuditEvent[]
  approvals             Approval[]
  slackQuestionClusters SlackQuestionCluster[]
  driftSuppressions     DriftSuppression[] // NEW: Phase 1 suppression system
  coverageSnapshots     CoverageSnapshot[] // NEW: Phase 3 Week 6 coverage monitoring
  auditTrails           AuditTrail[] // NEW: Phase 4 Week 8 comprehensive audit trail

  @@map("workspaces")
}

// Integrations (OAuth connections per workspace)
model Integration {
  id            BigInt   @id @default(autoincrement())
  workspaceId   String   @map("workspace_id")
  type          String // 'github', 'pagerduty', 'slack', 'confluence', 'notion'
  status        String   @default("pending") // 'pending', 'connected', 'error', 'revoked'
  config        Json     @default("{}")
  webhookSecret String?  @map("webhook_secret")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, type])
  @@map("integrations")
}

// Signal Events (workspace-scoped, composite primary key)
model SignalEvent {
  workspaceId String   @map("workspace_id")
  id          String // eventId from source (e.g., github_pr_owner/repo_123)
  sourceType  String   @map("source_type") // 'github_pr', 'pagerduty_incident', 'slack_cluster'
  occurredAt  DateTime @map("occurred_at")
  service     String?
  repo        String?
  severity    String? // 'sev1', 'sev2', 'sev3', 'sev4'
  extracted   Json     @default("{}")
  rawPayload  Json     @map("raw_payload")
  createdAt   DateTime @default(now()) @map("created_at")

  // NEW: For incident-based signals (Phase 3)
  incidentId  String?  @map("incident_id")
  incidentUrl String?  @map("incident_url")
  responders  String[] @default([])

  // NEW: For Slack-based signals (Phase 4)
  slackClusterId String? @map("slack_cluster_id")
  messageCount   Int?    @map("message_count")

  workspace       Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  driftCandidates DriftCandidate[]

  @@id([workspaceId, id])
  @@index([workspaceId, sourceType, occurredAt(sort: Desc)])
  @@index([workspaceId, service, occurredAt(sort: Desc)])
  @@map("signal_events")
}

// Drift Candidates (state machine entity)
model DriftCandidate {
  workspaceId   String @map("workspace_id")
  id            String @default(uuid())
  signalEventId String @map("signal_event_id")

  // State machine (18 states)
  state          String   @default("INGESTED") // DriftState enum
  stateUpdatedAt DateTime @default(now()) @map("state_updated_at")

  // Source context
  sourceType String  @map("source_type")
  service    String?
  repo       String?

  // Drift classification
  driftType    String?  @map("drift_type") // 'instruction', 'process', 'ownership', 'coverage', 'environment_tooling'
  driftDomains String[] @map("drift_domains")

  // Phase 1 Day 1: Deterministic drift classification
  comparisonResult      Json?    @map("comparison_result")       // Complete comparison result from deterministic comparison
  classificationMethod  String?  @map("classification_method")   // 'deterministic' | 'llm' - which method was used
  llmDriftType          String?  @map("llm_drift_type")          // Original LLM classification (for audit trail)
  llmConfidence         Float?   @map("llm_confidence")          // Original LLM confidence (for audit trail)

  // Evidence & scoring
  evidenceSummary   String? @map("evidence_summary")
  confidence        Float?
  driftScore        Float?  @map("drift_score")
  riskLevel         String? @map("risk_level") // 'low', 'medium', 'high'
  recommendedAction String? @map("recommended_action") // 'generate_patch', 'annotate_only', 'review_queue', 'ignore'

  // Drift Verdict (Phase 1 Quick Win - Comparison-based verdict)
  // Stores the explicit comparison-based drift decision
  driftVerdict Json? @map("drift_verdict") // { hasMatch: boolean, confidence: number, source: string, evidence: string[], comparisonType: string }

  // NEW: Evidence Bundle (Phase 1 - Truth-making system)
  // Complete deterministic evidence bundle for reproducible decisions
  evidenceBundle Json? @map("evidence_bundle")

  // NEW: Impact Assessment (Phase 1 - Multi-source impact)
  impactScore        Float?  @map("impact_score")        // 0-1 scale
  impactBand         String? @map("impact_band")         // 'low', 'medium', 'high', 'critical'
  impactJson         Json?   @map("impact_json")         // Complete impact assessment details
  consequenceText    String? @map("consequence_text")    // Human-readable consequence
  impactAssessedAt   DateTime? @map("impact_assessed_at") // When impact was assessed

  // NEW: Fingerprints for suppression (Phase 1 - Fatigue reduction)
  fingerprintStrict  String? @map("fingerprint_strict")  // Exact match fingerprint
  fingerprintMedium  String? @map("fingerprint_medium")  // Normalized token fingerprint
  fingerprintBroad   String? @map("fingerprint_broad")   // High-level pattern fingerprint

  // Document targeting
  docCandidates    Json     @default("[]") @map("doc_candidates")
  baselineFindings Json     @default("[]") @map("baseline_findings")
  targetDocSystems String[] @default([]) @map("target_doc_systems") // Multi-source enrichment: allowed doc systems for this source+drift combo

  // Doc resolution tracking (per spec Section C)
  docsResolutionStatus     String? @map("docs_resolution_status") // 'mapped' | 'explicit_link' | 'search_candidate' | 'needs_mapping' | 'ignored'
  docsResolutionMethod     String? @map("docs_resolution_method") // 'mapping' | 'pr_link' | 'confluence_search' | 'none'
  docsResolutionConfidence Float?  @map("docs_resolution_confidence")
  noWritebackMode          Boolean @default(false) @map("no_writeback_mode") // Set when writeback should be skipped

  // Selected doc details (per spec Section 0.1)
  selectedDocId    String? @map("selected_doc_id")
  selectedDocUrl   String? @map("selected_doc_url")
  selectedDocTitle String? @map("selected_doc_title")

  // Idempotency + debuggability fields (per spec Section 0.1)
  // Black box flight recorder - full DocResolutionResult blob for debugging resolution steps
  docsResolution   Json?   @map("docs_resolution")
  // DocContext snapshot - for LLM call reproducibility
  docContext       Json?   @map("doc_context")
  // Confluence version at fetch time - for detecting concurrent edits
  baseRevision     String? @map("base_revision")
  // Stable fingerprint of context slice - for cache/dedup
  docContextSha256 String? @map("doc_context_sha256")

  // Owner resolution
  ownerResolution Json? @map("owner_resolution")

  // Deduplication (fingerprint = hash of workspace + service + drift_type + domains + doc_id + key_tokens)
  fingerprint String?

  // Needs-mapping notification deduplication (per spec Section 7)
  // Key format: "workspace_id:repo" - used to prevent spam for same repo
  needsMappingKey        String?   @map("needs_mapping_key")
  needsMappingNotifiedAt DateTime? @map("needs_mapping_notified_at")

  // Correlated signals (from SignalJoiner - Phase 4)
  correlatedSignals Json    @default("[]") @map("correlated_signals")
  correlationBoost  Float   @default(0) @map("correlation_boost")
  correlationReason String? @map("correlation_reason")

  // Multi-source enrichment metadata (Points 2-10)
  patchStyle             String? @map("patch_style") // Point 6: Output-specific patch style
  sectionPattern         String? @map("section_pattern") // Point 4: Target section pattern
  sourceConfidenceWeight Float?  @map("source_confidence_weight") // Point 5: Source-specific confidence weight
  preValidationPassed    Boolean @default(true) @map("pre_validation_passed") // Point 7: Pre-validation result
  sourceThreshold        Float?  @map("source_threshold") // Point 8: Source-specific threshold
  correlationScore       Float?  @map("correlation_score") // Point 9: Cross-source correlation score

  // Error tracking
  lastErrorCode    String? @map("last_error_code")
  lastErrorMessage String? @map("last_error_message")
  retryCount       Int     @default(0) @map("retry_count")

  // Observability (Phase 4)
  traceId String? @map("trace_id") // End-to-end trace ID for logging and debugging

  // Plan tracking (Gap #6: DriftPlan as True Control-Plane)
  activePlanId      String? @map("active_plan_id")      // Which plan was active when this drift was processed
  activePlanVersion Int?    @map("active_plan_version") // Plan version at processing time
  activePlanHash    String? @map("active_plan_hash")    // Plan hash for reproducibility

  createdAt DateTime @default(now()) @map("created_at")

  workspace      Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  signalEvent    SignalEvent     @relation(fields: [workspaceId, signalEventId], references: [workspaceId, id], onDelete: Cascade)
  patchProposals PatchProposal[]

  @@id([workspaceId, id])
  @@unique([workspaceId, fingerprint])
  @@index([workspaceId, state, stateUpdatedAt(sort: Desc)])
  @@index([workspaceId, service])
  @@index([workspaceId, needsMappingKey, needsMappingNotifiedAt])
  @@index([traceId])
  @@map("drift_candidates")
}

// Patch Proposals (generated patches awaiting approval)
model PatchProposal {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  driftId     String @map("drift_id")

  // Target document
  docSystem String  @map("doc_system") // 'confluence', 'notion'
  docId     String  @map("doc_id")
  docTitle  String  @map("doc_title")
  docUrl    String? @map("doc_url")

  // Patch content
  baseRevision String? @map("base_revision")
  patchStyle   String  @default("replace_steps") @map("patch_style") // 'replace_steps', 'add_note', 'reorder_steps', 'update_owner_block', 'add_section', 'link_patch'
  unifiedDiff  String  @map("unified_diff") @db.Text

  // Metadata
  sourcesUsed Json    @default("[]") @map("sources_used")
  confidence  Float   @default(0)
  summary     String?

  // Validation
  validatorReport Json @default("{}") @map("validator_report")

  // Status
  status String @default("proposed") // 'proposed', 'sent', 'approved', 'edited', 'rejected', 'snoozed', 'written_back'

  // Slack tracking
  slackChannel String? @map("slack_channel")
  slackTs      String? @map("slack_ts")

  // Notification tracking
  lastNotifiedAt    DateTime? @map("last_notified_at")
  notificationCount Int       @default(0) @map("notification_count")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace      Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  driftCandidate DriftCandidate @relation(fields: [workspaceId, driftId], references: [workspaceId, id], onDelete: Cascade)
  approvals      Approval[]

  @@id([workspaceId, id])
  @@index([workspaceId, docSystem, docId])
  @@index([workspaceId, status, updatedAt(sort: Desc)])
  @@map("patch_proposals")
}

// NEW: Drift Suppression Model (Phase 1 - Fatigue reduction)
model DriftSuppression {
  workspaceId        String   @map("workspace_id")
  id                 String   @default(cuid()) @map("id")
  fingerprint        String   @map("fingerprint")
  fingerprintLevel   String   @map("fingerprint_level") // 'strict', 'medium', 'broad'
  suppressionType    String   @map("suppression_type")  // 'false_positive', 'snooze', 'permanent'
  reason             String?  @map("reason")
  createdBy          String?  @map("created_by")
  expiresAt          DateTime? @map("expires_at")
  falsePositiveCount Int      @default(0) @map("false_positive_count")
  lastSeenAt         DateTime? @map("last_seen_at")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@unique([workspaceId, fingerprint])
  @@index([workspaceId, fingerprint])
  @@index([workspaceId, expiresAt])
  @@map("drift_suppressions")
}

// Approvals (append-only audit log for human actions)
model Approval {
  workspaceId       String    @map("workspace_id")
  id                String    @default(uuid())
  patchId           String    @map("patch_id")
  action            String // 'approve', 'edit', 'reject', 'snooze'
  actorSlackId      String    @map("actor_slack_id")
  actorName         String?   @map("actor_name")
  note              String?
  editedDiff        String?   @map("edited_diff") @db.Text
  snoozeUntil       DateTime? @map("snooze_until")
  rejectionCategory String?   @map("rejection_category")
  createdAt         DateTime  @default(now()) @map("created_at")

  workspace     Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  patchProposal PatchProposal @relation(fields: [workspaceId, patchId], references: [workspaceId, id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, patchId, createdAt(sort: Desc)])
  @@map("approvals")
}

// Doc Mappings V2 (with primary doc flag and managed region tracking)
model DocMappingV2 {
  workspaceId              String    @map("workspace_id")
  id                       BigInt    @id @default(autoincrement())
  service                  String?
  repo                     String?
  docSystem                String    @map("doc_system") // 'confluence', 'notion', 'github_readme', 'github_swagger', 'backstage'
  docId                    String    @map("doc_id")
  docTitle                 String    @map("doc_title")
  docUrl                   String?   @map("doc_url")
  spaceKey                 String?   @map("space_key") // Confluence space key for doc resolution
  isPrimary                Boolean   @default(false) @map("is_primary")
  hasManagedRegion         Boolean   @default(false) @map("has_managed_region")
  managedRegionInstalledAt DateTime? @map("managed_region_installed_at")
  docClass                 String?   @map("doc_class") // e.g., 'Operational_Runbook', 'Architecture_Doc', 'API_Reference'
  allowWriteback           Boolean   @default(true) @map("allow_writeback") // Per spec: controls if writeback is allowed for this mapping
  createdAt                DateTime  @default(now()) @map("created_at")
  updatedAt                DateTime  @updatedAt @map("updated_at")

  // NEW: Multi-source fields (Phase 1)
  docCategory       String?  @map("doc_category") // 'functional' | 'developer' | 'operational'
  filePath          String?  @map("file_path") // For GitHub-based docs: "README.md", "docs/api.yaml"
  driftTypeAffinity String[] @default([]) @map("drift_type_affinity") // Drift types this doc is relevant for
  sourceType        String?  @map("source_type") // 'github_pr' | 'pagerduty_incident' | 'slack_cluster' | etc. NULL = applies to all sources

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, docSystem, docId])
  @@index([workspaceId, service])
  @@index([workspaceId, repo])
  @@index([workspaceId, docCategory])
  @@index([workspaceId, repo, sourceType])
  @@map("doc_mappings_v2")
}

// Owner Mappings (service/repo to owner resolution)
model OwnerMapping {
  workspaceId String   @map("workspace_id")
  id          BigInt   @id @default(autoincrement())
  service     String?
  repo        String?
  ownerType   String   @map("owner_type") // 'slack_user', 'slack_channel', 'team'
  ownerRef    String   @map("owner_ref")
  source      String   @default("manual") // 'manual', 'pagerduty', 'codeowners', 'commit_history'
  createdAt   DateTime @default(now()) @map("created_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, service])
  @@index([workspaceId, repo])
  @@map("owner_mappings")
}

// Audit Events (system-wide event log)
model AuditEvent {
  workspaceId String   @map("workspace_id")
  id          BigInt   @id @default(autoincrement())
  entityType  String   @map("entity_type") // 'signal', 'drift', 'patch', 'approval', 'writeback', 'integration'
  entityId    String   @map("entity_id")
  eventType   String   @map("event_type")
  payload     Json     @default("{}")
  actorType   String?  @map("actor_type") // 'system', 'user', 'webhook'
  actorId     String?  @map("actor_id")
  createdAt   DateTime @default(now()) @map("created_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, entityType, entityId, createdAt(sort: Desc)])
  @@index([workspaceId, createdAt(sort: Desc)])
  @@map("audit_events")
}

// ======================================================================
// LEGACY MODELS (kept for gradual migration)
// Will be removed after data migration to new models is complete
// ======================================================================

// Multi-tenant organizations (LEGACY - use Workspace instead)
model Organization {
  id                    String   @id @default(uuid())
  name                  String
  slackWorkspaceId      String?  @unique @map("slack_workspace_id")
  slackBotToken         String?  @map("slack_bot_token")
  slackTeamName         String?  @map("slack_team_name")
  confluenceCloudId     String?  @map("confluence_cloud_id")
  confluenceAccessToken String?  @map("confluence_access_token")
  githubInstallationId  BigInt?  @map("github_installation_id")
  settings              Json     @default("{}")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  users            User[]
  trackedDocuments TrackedDocument[]
  docMappings      DocMapping[]
  signals          Signal[]
  diffProposals    DiffProposal[]
  auditLogs        AuditLog[]
  metricsSnapshots MetricsSnapshot[]

  @@map("organizations")
}

// Users (Slack-based identity)
model User {
  id             String   @id @default(uuid())
  orgId          String   @map("org_id")
  slackUserId    String   @map("slack_user_id")
  email          String?
  name           String?
  githubUsername String?  @map("github_username")
  isAdmin        Boolean  @default(false) @map("is_admin")
  createdAt      DateTime @default(now()) @map("created_at")

  organization      Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  ownedDocuments    TrackedDocument[] @relation("DocumentOwner")
  routedProposals   DiffProposal[]    @relation("RoutedTo")
  resolvedProposals DiffProposal[]    @relation("ResolvedBy")
  auditLogs         AuditLog[]

  @@unique([orgId, slackUserId])
  @@map("users")
}

// Docs we're actively monitoring
model TrackedDocument {
  id                  String    @id @default(uuid())
  orgId               String    @map("org_id")
  confluencePageId    String    @map("confluence_page_id")
  title               String
  contentHash         String?   @map("content_hash")
  lastContentSnapshot String?   @map("last_content_snapshot") @db.Text
  lastSyncedAt        DateTime? @map("last_synced_at")
  freshnessScore      Decimal   @default(1.0) @map("freshness_score") @db.Decimal(3, 2)
  ownerUserId         String?   @map("owner_user_id")
  ownerSource         String?   @map("owner_source")
  repoMapping         String[]  @map("repo_mapping")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  organization  Organization   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  owner         User?          @relation("DocumentOwner", fields: [ownerUserId], references: [id])
  docMappings   DocMapping[]
  diffProposals DiffProposal[]
  auditLogs     AuditLog[]

  @@unique([orgId, confluencePageId])
  @@index([orgId])
  @@map("tracked_documents")
}

// Service/repo to doc mapping
model DocMapping {
  id           String   @id @default(uuid())
  orgId        String   @map("org_id")
  repoFullName String   @map("repo_full_name")
  pathPatterns String[] @map("path_patterns")
  serviceName  String?  @map("service_name")
  documentId   String   @map("document_id")
  createdAt    DateTime @default(now()) @map("created_at")

  organization Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  document     TrackedDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([orgId, repoFullName, documentId])
  @@map("doc_mappings")
}

// Incoming signals (GitHub PRs for MVP)
model Signal {
  id            String    @id @default(uuid())
  orgId         String    @map("org_id")
  type          String // 'github_pr', 'pagerduty_incident', 'slack_question'
  externalId    String    @map("external_id")
  repoFullName  String?   @map("repo_full_name")
  payload       Json
  driftAnalysis Json?     @map("drift_analysis")
  processedAt   DateTime? @map("processed_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  organization  Organization   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  diffProposals DiffProposal[]

  @@unique([orgId, type, externalId])
  @@index([orgId, createdAt(sort: Desc)])
  @@map("signals")
}

// Generated diff proposals
model DiffProposal {
  id         String  @id @default(uuid())
  orgId      String  @map("org_id")
  signalId   String? @map("signal_id")
  documentId String? @map("document_id")

  // The diff itself
  diffContent       String   @map("diff_content")
  summary           String?
  rationale         String?
  confidence        Decimal? @db.Decimal(3, 2)
  suspectedSections String[] @map("suspected_sections")
  sourceLinks       String[] @map("source_links")

  // Routing
  routedToUserId    String? @map("routed_to_user_id")
  routingConfidence String? @map("routing_confidence")

  // Approval state
  status         String    @default("pending")
  slackChannelId String?   @map("slack_channel_id")
  slackMessageTs String?   @map("slack_message_ts")
  snoozeUntil    DateTime? @map("snooze_until")

  // Resolution
  resolvedAt        DateTime? @map("resolved_at")
  resolvedByUserId  String?   @map("resolved_by_user_id")
  rejectionReason   String?   @map("rejection_reason")
  rejectionTags     String[]  @map("rejection_tags")
  editedDiffContent String?   @map("edited_diff_content")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  organization Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  signal       Signal?          @relation(fields: [signalId], references: [id])
  document     TrackedDocument? @relation(fields: [documentId], references: [id])
  routedTo     User?            @relation("RoutedTo", fields: [routedToUserId], references: [id])
  resolvedBy   User?            @relation("ResolvedBy", fields: [resolvedByUserId], references: [id])
  auditLogs    AuditLog[]

  @@index([orgId, status])
  @@index([routedToUserId, status])
  @@map("diff_proposals")
}

// Full audit trail
model AuditLog {
  id             String   @id @default(uuid())
  orgId          String   @map("org_id")
  action         String // 'proposal_created', 'approved', 'rejected', 'edited', 'writeback_success'
  actorUserId    String?  @map("actor_user_id")
  documentId     String?  @map("document_id")
  diffProposalId String?  @map("diff_proposal_id")
  metadata       Json     @default("{}")
  createdAt      DateTime @default(now()) @map("created_at")

  organization Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  actor        User?            @relation(fields: [actorUserId], references: [id])
  document     TrackedDocument? @relation(fields: [documentId], references: [id])
  diffProposal DiffProposal?    @relation(fields: [diffProposalId], references: [id])

  @@index([orgId, createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Metrics snapshots (for dashboard)
model MetricsSnapshot {
  id                     String   @id @default(uuid())
  orgId                  String   @map("org_id")
  date                   DateTime @db.Date
  totalSignals           Int      @default(0) @map("total_signals")
  totalProposals         Int      @default(0) @map("total_proposals")
  approvedCount          Int      @default(0) @map("approved_count")
  editedCount            Int      @default(0) @map("edited_count")
  rejectedCount          Int      @default(0) @map("rejected_count")
  snoozedCount           Int      @default(0) @map("snoozed_count")
  avgTimeToApprovalHours Decimal? @map("avg_time_to_approval_hours") @db.Decimal(10, 2)
  docsUpdatedCount       Int      @default(0) @map("docs_updated_count")
  createdAt              DateTime @default(now()) @map("created_at")

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, date])
  @@map("metrics_snapshots")
}

// Slack Question Clusters (Phase 4: Knowledge Gap Detection)
model SlackQuestionCluster {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  channelId   String @map("channel_id")
  channelName String @map("channel_name")

  // Cluster metadata
  representativeQuestion String   @map("representative_question")
  topic                  String   @default("general")
  messageCount           Int      @map("message_count")
  uniqueAskers           Int      @map("unique_askers")
  firstSeen              DateTime @map("first_seen")
  lastSeen               DateTime @map("last_seen")

  // Processing state
  processedAt   DateTime? @map("processed_at")
  signalEventId String?   @map("signal_event_id")

  // Raw data
  sampleMessages Json @map("sample_messages")

  // Similarity scoring
  avgSimilarity Float @default(0) @map("avg_similarity")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, lastSeen(sort: Desc)])
  @@index([workspaceId, processedAt])
  @@map("slack_question_clusters")
}

// ======================================================================
// DRIFT PLAN (Phase 3: Control-Plane Architecture)
// Versioned plans for reproducible drift detection and remediation
// ======================================================================

model DriftPlan {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Plan metadata
  name        String
  description String?
  status      String @default("active") // 'active', 'archived', 'draft'

  // Scope definition (5-step resolution hierarchy)
  scopeType String // 'workspace', 'service', 'repo'
  scopeRef  String? // service ID or repo full name (null for workspace scope)

  // Primary documentation target
  primaryDocId     String? @map("primary_doc_id") // Doc ID in the doc system
  primaryDocSystem String? @map("primary_doc_system") // 'confluence', 'notion', 'github_readme', etc.
  docClass         String? @map("doc_class") // 'runbook', 'api_contract', 'service_catalog', etc.

  // Plan configuration
  inputSources   String[] @default([]) @map("input_sources") // Allowed source types: ['github_pr', 'pagerduty_incident', ...]
  driftTypes     String[] @default([]) @map("drift_types") // Allowed drift types: ['instruction', 'process', ...]
  allowedOutputs String[] @default([]) @map("allowed_outputs") // Allowed output targets: ['confluence', 'notion', ...]

  // Plan rules and thresholds (JSON for flexibility)
  thresholds     Json @default("{}") // { minConfidence: 0.7, minImpactScore: 0.5, ... }
  eligibility    Json @default("{}") // { requiresIncident: false, minSeverity: 'sev3', ... }
  sectionTargets Json @default("{}") // { instruction: 'Deployment Steps', process: 'Runbook', ... }
  impactRules    Json @default("{}") // Custom impact rules for this plan
  writeback      Json @default("{}") // { enabled: true, requiresApproval: false, ... }

  // Versioning for reproducibility
  version     Int    @default(1) // Incremented on each update
  versionHash String @map("version_hash") // SHA-256 hash of plan content for reproducibility
  parentId    String? @map("parent_id") // Reference to previous version (for version history)

  // Template reference (if created from template)
  templateId   String? @map("template_id") // Reference to template used
  templateName String? @map("template_name") // Template name for display

  // Audit trail
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by") // User email or ID
  updatedBy String?  @map("updated_by") // User email or ID

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@unique([workspaceId, versionHash]) // Ensure unique content hashes per workspace
  @@index([workspaceId, status])
  @@index([workspaceId, scopeType, scopeRef])
  @@index([workspaceId, templateId])
  @@map("drift_plans")
}

// ======================================================================
// PLAN RUN TRACKING (Gap #6: DriftPlan as True Control-Plane)
// Tracks which drifts were processed under which plan version
// ======================================================================

model PlanRun {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Plan reference
  planId      String @map("plan_id")
  planVersion Int    @map("plan_version") // Snapshot of plan version at execution time
  planHash    String @map("plan_hash") // Snapshot of plan hash for reproducibility

  // Drift reference
  driftId String @map("drift_id")

  // Execution metadata
  executedAt DateTime @default(now()) @map("executed_at")

  // Routing decision (captured at execution time)
  routingAction String @map("routing_action") // 'auto_approve', 'slack_notify', 'digest_only', 'ignore'
  confidence    Float  // Confidence score at execution time

  // Thresholds used (snapshot for reproducibility)
  thresholdsUsed Json @map("thresholds_used") // { autoApprove: 0.98, slackNotify: 0.40, ... }

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, planId])
  @@index([workspaceId, driftId])
  @@index([workspaceId, executedAt])
  @@index([workspaceId, routingAction])
  @@map("plan_runs")
}

// ======================================================================
// COVERAGE HEALTH MONITORING (Phase 3, Week 6)
// Daily snapshots of coverage metrics for monitoring and alerting
// ======================================================================

model CoverageSnapshot {
  workspaceId String   @map("workspace_id")
  id          String   @default(uuid())
  snapshotAt  DateTime @map("snapshot_at") // Timestamp of snapshot

  // Mapping Coverage Metrics
  totalServices           Int @default(0) @map("total_services") // Total unique services seen
  servicesMapped          Int @default(0) @map("services_mapped") // Services with doc mappings
  totalRepos              Int @default(0) @map("total_repos") // Total unique repos seen
  reposMapped             Int @default(0) @map("repos_mapped") // Repos with doc mappings
  mappingCoveragePercent  Float @default(0) @map("mapping_coverage_percent") // Overall mapping coverage

  // Processing Coverage Metrics
  totalSignals            Int @default(0) @map("total_signals") // Total signals in period
  signalsProcessed        Int @default(0) @map("signals_processed") // Signals that created drift candidates
  signalsIgnored          Int @default(0) @map("signals_ignored") // Signals ignored (no mapping, filtered, etc.)
  processingCoveragePercent Float @default(0) @map("processing_coverage_percent") // Signals processed / total

  // Source Health Metrics (JSON structure)
  // { "github_pr": { "total": 100, "processed": 80, "ignored": 20, "health": "good" }, ... }
  sourceHealth Json @default("{}") @map("source_health")

  // Drift Type Distribution (JSON structure)
  // { "instruction": 45, "process": 30, "ownership": 15, "coverage": 10 }
  driftTypeDistribution Json @default("{}") @map("drift_type_distribution")

  // Coverage Obligations Status (JSON structure)
  // { "mapping_coverage": { "threshold": 0.8, "actual": 0.75, "met": false }, ... }
  obligationsStatus Json @default("{}") @map("obligations_status")

  // Metadata
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, snapshotAt])
  @@map("coverage_snapshots")
}

// ======================================================================
// AUDIT TRAIL SYSTEM (Phase 4 Week 8)
// Immutable audit trail for compliance and debugging
// Renamed from AuditLog to AuditTrail to avoid conflict with legacy model
// ======================================================================

model AuditTrail {
  workspaceId String   @map("workspace_id")
  id          String   @default(uuid())
  timestamp   DateTime @default(now())

  // Event classification
  eventType   String   @map("event_type") // 'state_transition', 'evidence_created', 'plan_changed', 'approval', 'rejection', etc.
  category    String   @default("system") // 'system', 'user', 'integration', 'compliance'
  severity    String   @default("info") // 'debug', 'info', 'warning', 'error', 'critical'

  // Entity being audited
  entityType  String   @map("entity_type") // 'drift_candidate', 'patch_proposal', 'drift_plan', 'evidence_bundle', etc.
  entityId    String   @map("entity_id")

  // Actor who triggered the event
  actorType   String   @map("actor_type") // 'system', 'user', 'integration', 'agent'
  actorId     String   @map("actor_id") // User email, agent name, integration ID, etc.

  // State transition details (for drift candidates)
  fromState   String?  @map("from_state") // Previous state (if state transition)
  toState     String?  @map("to_state") // New state (if state transition)

  // Change details
  changes     Json     @default("{}") // Structured diff of what changed
  metadata    Json     @default("{}") // Additional context (error details, user input, etc.)

  // Evidence bundle tracking
  evidenceBundleHash String? @map("evidence_bundle_hash") // SHA-256 hash of evidence bundle (if applicable)
  impactBand         String? @map("impact_band") // Impact band at time of event (if applicable)

  // Plan version tracking
  planId             String? @map("plan_id") // DriftPlan ID (if applicable)
  planVersionHash    String? @map("plan_version_hash") // SHA-256 hash of plan version (if applicable)

  // Compliance flags
  requiresRetention  Boolean @default(false) @map("requires_retention") // Flag for compliance retention
  retentionUntil     DateTime? @map("retention_until") // Retention expiry date
  complianceTag      String? @map("compliance_tag") // SOX, SOC2, ISO27001, GDPR, etc.

  // Immutability - once created, never updated
  // No updatedAt field - audit trails are append-only

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, timestamp])
  @@index([workspaceId, entityType, entityId])
  @@index([workspaceId, eventType, timestamp])
  @@index([workspaceId, actorId, timestamp])
  @@index([workspaceId, category, severity, timestamp])
  @@index([evidenceBundleHash])
  @@index([planVersionHash])
  @@map("audit_trails")
}
