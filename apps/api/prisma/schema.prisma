// Prisma schema for VertaAI
// Knowledge Drift Agent for Engineering Ops

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ======================================================================
// NEW MODELS (Phase 1: Workspace-based multi-tenancy)
// These coexist with Organization model for gradual migration
// ======================================================================

// Workspaces (new multi-tenant model - replaces Organization)
model Workspace {
  id         String @id @default(uuid())
  name       String
  slug       String @unique
  ownerEmail String @map("owner_email")

  // Ownership config (for owner resolution)
  ownershipSourceRanking String[] @default(["pagerduty", "codeowners", "manual"]) @map("ownership_source_ranking")
  defaultOwnerType       String   @default("slack_channel") @map("default_owner_type")
  defaultOwnerRef        String   @default("#engineering") @map("default_owner_ref")

  // Notification policy (confidence-based routing)
  highConfidenceThreshold   Float   @default(0.70) @map("high_confidence_threshold")
  mediumConfidenceThreshold Float   @default(0.55) @map("medium_confidence_threshold")
  digestChannel             String? @map("digest_channel")

  // Workspace policy for doc resolution (per spec Section 1.1 + Section 7)
  primaryDocRequired        Boolean @default(false) @map("primary_doc_required") // If true, fail if no primary doc mapping exists
  allowPrLinkOverride       Boolean @default(true) @map("allow_pr_link_override") // Allow PR links to override mappings
  allowSearchSuggestMapping Boolean @default(false) @map("allow_search_suggest_mapping") // Allow search-based suggestions (P2)
  minConfidenceForSuggest   Float   @default(0.6) @map("min_confidence_for_suggest") // Min confidence for search suggest
  allowedConfluenceSpaces   String[] @default([]) @map("allowed_confluence_spaces") // Space key allowlist (empty = allow all)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  integrations    Integration[]
  signalEvents    SignalEvent[]
  driftCandidates DriftCandidate[]
  patchProposals  PatchProposal[]
  docMappingsV2   DocMappingV2[]
  ownerMappings   OwnerMapping[]
  auditEvents     AuditEvent[]
  approvals       Approval[]

  @@map("workspaces")
}

// Integrations (OAuth connections per workspace)
model Integration {
  id            BigInt   @id @default(autoincrement())
  workspaceId   String   @map("workspace_id")
  type          String // 'github', 'pagerduty', 'slack', 'confluence', 'notion'
  status        String   @default("pending") // 'pending', 'connected', 'error', 'revoked'
  config        Json     @default("{}")
  webhookSecret String?  @map("webhook_secret")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, type])
  @@map("integrations")
}

// Signal Events (workspace-scoped, composite primary key)
model SignalEvent {
  workspaceId String   @map("workspace_id")
  id          String // eventId from source (e.g., github_pr_owner/repo_123)
  sourceType  String   @map("source_type") // 'github_pr', 'pagerduty_incident', 'slack_cluster'
  occurredAt  DateTime @map("occurred_at")
  service     String?
  repo        String?
  severity    String? // 'sev1', 'sev2', 'sev3', 'sev4'
  extracted   Json     @default("{}")
  rawPayload  Json     @map("raw_payload")
  createdAt   DateTime @default(now()) @map("created_at")

  // NEW: For incident-based signals (Phase 3)
  incidentId  String?  @map("incident_id")
  incidentUrl String?  @map("incident_url")
  responders  String[] @default([])

  // NEW: For Slack-based signals (Phase 4)
  slackClusterId String? @map("slack_cluster_id")
  messageCount   Int?    @map("message_count")

  workspace       Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  driftCandidates DriftCandidate[]

  @@id([workspaceId, id])
  @@index([workspaceId, sourceType, occurredAt(sort: Desc)])
  @@index([workspaceId, service, occurredAt(sort: Desc)])
  @@map("signal_events")
}

// Drift Candidates (state machine entity)
model DriftCandidate {
  workspaceId   String @map("workspace_id")
  id            String @default(uuid())
  signalEventId String @map("signal_event_id")

  // State machine (18 states)
  state          String   @default("INGESTED") // DriftState enum
  stateUpdatedAt DateTime @default(now()) @map("state_updated_at")

  // Source context
  sourceType String  @map("source_type")
  service    String?
  repo       String?

  // Drift classification
  driftType    String?  @map("drift_type") // 'instruction', 'process', 'ownership', 'coverage', 'environment_tooling'
  driftDomains String[] @map("drift_domains")

  // Evidence & scoring
  evidenceSummary   String? @map("evidence_summary")
  confidence        Float?
  driftScore        Float?  @map("drift_score")
  riskLevel         String? @map("risk_level") // 'low', 'medium', 'high'
  recommendedAction String? @map("recommended_action") // 'generate_patch', 'annotate_only', 'review_queue', 'ignore'

  // Document targeting
  docCandidates    Json @default("[]") @map("doc_candidates")
  baselineFindings Json @default("[]") @map("baseline_findings")

  // Doc resolution tracking (per spec Section C)
  docsResolutionStatus     String? @map("docs_resolution_status") // 'mapped' | 'explicit_link' | 'search_candidate' | 'needs_mapping' | 'ignored'
  docsResolutionMethod     String? @map("docs_resolution_method") // 'mapping' | 'pr_link' | 'confluence_search' | 'none'
  docsResolutionConfidence Float?  @map("docs_resolution_confidence")
  noWritebackMode          Boolean @default(false) @map("no_writeback_mode") // Set when writeback should be skipped

  // Selected doc details (per spec Section 0.1)
  selectedDocId    String? @map("selected_doc_id")
  selectedDocUrl   String? @map("selected_doc_url")
  selectedDocTitle String? @map("selected_doc_title")

  // Idempotency + debuggability fields (per spec Section 0.1)
  // Black box flight recorder - full DocResolutionResult blob for debugging resolution steps
  docsResolution   Json?   @map("docs_resolution")
  // DocContext snapshot - for LLM call reproducibility
  docContext       Json?   @map("doc_context")
  // Confluence version at fetch time - for detecting concurrent edits
  baseRevision     String? @map("base_revision")
  // Stable fingerprint of context slice - for cache/dedup
  docContextSha256 String? @map("doc_context_sha256")

  // Owner resolution
  ownerResolution Json? @map("owner_resolution")

  // Deduplication (fingerprint = hash of workspace + service + drift_type + domains + doc_id + key_tokens)
  fingerprint String?

  // Needs-mapping notification deduplication (per spec Section 7)
  // Key format: "workspace_id:repo" - used to prevent spam for same repo
  needsMappingKey        String?   @map("needs_mapping_key")
  needsMappingNotifiedAt DateTime? @map("needs_mapping_notified_at")

  // Correlated signals (from SignalJoiner - Phase 4)
  correlatedSignals  Json    @default("[]") @map("correlated_signals")
  correlationBoost   Float   @default(0) @map("correlation_boost")
  correlationReason  String? @map("correlation_reason")

  // Error tracking
  lastErrorCode    String? @map("last_error_code")
  lastErrorMessage String? @map("last_error_message")
  retryCount       Int     @default(0) @map("retry_count")

  createdAt DateTime @default(now()) @map("created_at")

  workspace      Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  signalEvent    SignalEvent     @relation(fields: [workspaceId, signalEventId], references: [workspaceId, id], onDelete: Cascade)
  patchProposals PatchProposal[]

  @@id([workspaceId, id])
  @@unique([workspaceId, fingerprint])
  @@index([workspaceId, state, stateUpdatedAt(sort: Desc)])
  @@index([workspaceId, service])
  @@index([workspaceId, needsMappingKey, needsMappingNotifiedAt])
  @@map("drift_candidates")
}

// Patch Proposals (generated patches awaiting approval)
model PatchProposal {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  driftId     String @map("drift_id")

  // Target document
  docSystem String  @map("doc_system") // 'confluence', 'notion'
  docId     String  @map("doc_id")
  docTitle  String  @map("doc_title")
  docUrl    String? @map("doc_url")

  // Patch content
  baseRevision String? @map("base_revision")
  patchStyle   String  @default("replace_steps") @map("patch_style") // 'replace_steps', 'add_note', 'reorder_steps', 'update_owner_block', 'add_section', 'link_patch'
  unifiedDiff  String  @map("unified_diff") @db.Text

  // Metadata
  sourcesUsed Json    @default("[]") @map("sources_used")
  confidence  Float   @default(0)
  summary     String?

  // Validation
  validatorReport Json @default("{}") @map("validator_report")

  // Status
  status String @default("proposed") // 'proposed', 'sent', 'approved', 'edited', 'rejected', 'snoozed', 'written_back'

  // Slack tracking
  slackChannel String? @map("slack_channel")
  slackTs      String? @map("slack_ts")

  // Notification tracking
  lastNotifiedAt    DateTime? @map("last_notified_at")
  notificationCount Int       @default(0) @map("notification_count")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace      Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  driftCandidate DriftCandidate @relation(fields: [workspaceId, driftId], references: [workspaceId, id], onDelete: Cascade)
  approvals      Approval[]

  @@id([workspaceId, id])
  @@index([workspaceId, docSystem, docId])
  @@index([workspaceId, status, updatedAt(sort: Desc)])
  @@map("patch_proposals")
}

// Approvals (append-only audit log for human actions)
model Approval {
  workspaceId       String    @map("workspace_id")
  id                String    @default(uuid())
  patchId           String    @map("patch_id")
  action            String // 'approve', 'edit', 'reject', 'snooze'
  actorSlackId      String    @map("actor_slack_id")
  actorName         String?   @map("actor_name")
  note              String?
  editedDiff        String?   @map("edited_diff") @db.Text
  snoozeUntil       DateTime? @map("snooze_until")
  rejectionCategory String?   @map("rejection_category")
  createdAt         DateTime  @default(now()) @map("created_at")

  workspace     Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  patchProposal PatchProposal @relation(fields: [workspaceId, patchId], references: [workspaceId, id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, patchId, createdAt(sort: Desc)])
  @@map("approvals")
}

// Doc Mappings V2 (with primary doc flag and managed region tracking)
model DocMappingV2 {
  workspaceId              String    @map("workspace_id")
  id                       BigInt    @id @default(autoincrement())
  service                  String?
  repo                     String?
  docSystem                String    @map("doc_system") // 'confluence', 'notion', 'github_readme', 'github_swagger', 'backstage'
  docId                    String    @map("doc_id")
  docTitle                 String    @map("doc_title")
  docUrl                   String?   @map("doc_url")
  spaceKey                 String?   @map("space_key") // Confluence space key for doc resolution
  isPrimary                Boolean   @default(false) @map("is_primary")
  hasManagedRegion         Boolean   @default(false) @map("has_managed_region")
  managedRegionInstalledAt DateTime? @map("managed_region_installed_at")
  docClass                 String?   @map("doc_class") // e.g., 'Operational_Runbook', 'Architecture_Doc', 'API_Reference'
  allowWriteback           Boolean   @default(true) @map("allow_writeback") // Per spec: controls if writeback is allowed for this mapping
  createdAt                DateTime  @default(now()) @map("created_at")
  updatedAt                DateTime  @updatedAt @map("updated_at")

  // NEW: Multi-source fields (Phase 1)
  docCategory       String?  @map("doc_category")       // 'functional' | 'developer' | 'operational'
  filePath          String?  @map("file_path")          // For GitHub-based docs: "README.md", "docs/api.yaml"
  driftTypeAffinity String[] @default([]) @map("drift_type_affinity") // Drift types this doc is relevant for

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, docSystem, docId])
  @@index([workspaceId, service])
  @@index([workspaceId, repo])
  @@index([workspaceId, docCategory])
  @@map("doc_mappings_v2")
}

// Owner Mappings (service/repo to owner resolution)
model OwnerMapping {
  workspaceId String   @map("workspace_id")
  id          BigInt   @id @default(autoincrement())
  service     String?
  repo        String?
  ownerType   String   @map("owner_type") // 'slack_user', 'slack_channel', 'team'
  ownerRef    String   @map("owner_ref")
  source      String   @default("manual") // 'manual', 'pagerduty', 'codeowners', 'commit_history'
  createdAt   DateTime @default(now()) @map("created_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, service])
  @@index([workspaceId, repo])
  @@map("owner_mappings")
}

// Audit Events (system-wide event log)
model AuditEvent {
  workspaceId String   @map("workspace_id")
  id          BigInt   @id @default(autoincrement())
  entityType  String   @map("entity_type") // 'signal', 'drift', 'patch', 'approval', 'writeback', 'integration'
  entityId    String   @map("entity_id")
  eventType   String   @map("event_type")
  payload     Json     @default("{}")
  actorType   String?  @map("actor_type") // 'system', 'user', 'webhook'
  actorId     String?  @map("actor_id")
  createdAt   DateTime @default(now()) @map("created_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, entityType, entityId, createdAt(sort: Desc)])
  @@index([workspaceId, createdAt(sort: Desc)])
  @@map("audit_events")
}

// ======================================================================
// LEGACY MODELS (kept for gradual migration)
// Will be removed after data migration to new models is complete
// ======================================================================

// Multi-tenant organizations (LEGACY - use Workspace instead)
model Organization {
  id                    String   @id @default(uuid())
  name                  String
  slackWorkspaceId      String?  @unique @map("slack_workspace_id")
  slackBotToken         String?  @map("slack_bot_token")
  slackTeamName         String?  @map("slack_team_name")
  confluenceCloudId     String?  @map("confluence_cloud_id")
  confluenceAccessToken String?  @map("confluence_access_token")
  githubInstallationId  BigInt?  @map("github_installation_id")
  settings              Json     @default("{}")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  users            User[]
  trackedDocuments TrackedDocument[]
  docMappings      DocMapping[]
  signals          Signal[]
  diffProposals    DiffProposal[]
  auditLogs        AuditLog[]
  metricsSnapshots MetricsSnapshot[]

  @@map("organizations")
}

// Users (Slack-based identity)
model User {
  id             String   @id @default(uuid())
  orgId          String   @map("org_id")
  slackUserId    String   @map("slack_user_id")
  email          String?
  name           String?
  githubUsername String?  @map("github_username")
  isAdmin        Boolean  @default(false) @map("is_admin")
  createdAt      DateTime @default(now()) @map("created_at")

  organization      Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  ownedDocuments    TrackedDocument[] @relation("DocumentOwner")
  routedProposals   DiffProposal[]    @relation("RoutedTo")
  resolvedProposals DiffProposal[]    @relation("ResolvedBy")
  auditLogs         AuditLog[]

  @@unique([orgId, slackUserId])
  @@map("users")
}

// Docs we're actively monitoring
model TrackedDocument {
  id                  String    @id @default(uuid())
  orgId               String    @map("org_id")
  confluencePageId    String    @map("confluence_page_id")
  title               String
  contentHash         String?   @map("content_hash")
  lastContentSnapshot String?   @map("last_content_snapshot") @db.Text
  lastSyncedAt        DateTime? @map("last_synced_at")
  freshnessScore      Decimal   @default(1.0) @map("freshness_score") @db.Decimal(3, 2)
  ownerUserId         String?   @map("owner_user_id")
  ownerSource         String?   @map("owner_source")
  repoMapping         String[]  @map("repo_mapping")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  organization  Organization   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  owner         User?          @relation("DocumentOwner", fields: [ownerUserId], references: [id])
  docMappings   DocMapping[]
  diffProposals DiffProposal[]
  auditLogs     AuditLog[]

  @@unique([orgId, confluencePageId])
  @@index([orgId])
  @@map("tracked_documents")
}

// Service/repo to doc mapping
model DocMapping {
  id           String   @id @default(uuid())
  orgId        String   @map("org_id")
  repoFullName String   @map("repo_full_name")
  pathPatterns String[] @map("path_patterns")
  serviceName  String?  @map("service_name")
  documentId   String   @map("document_id")
  createdAt    DateTime @default(now()) @map("created_at")

  organization Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  document     TrackedDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([orgId, repoFullName, documentId])
  @@map("doc_mappings")
}

// Incoming signals (GitHub PRs for MVP)
model Signal {
  id            String    @id @default(uuid())
  orgId         String    @map("org_id")
  type          String // 'github_pr', 'pagerduty_incident', 'slack_question'
  externalId    String    @map("external_id")
  repoFullName  String?   @map("repo_full_name")
  payload       Json
  driftAnalysis Json?     @map("drift_analysis")
  processedAt   DateTime? @map("processed_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  organization  Organization   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  diffProposals DiffProposal[]

  @@unique([orgId, type, externalId])
  @@index([orgId, createdAt(sort: Desc)])
  @@map("signals")
}

// Generated diff proposals
model DiffProposal {
  id         String  @id @default(uuid())
  orgId      String  @map("org_id")
  signalId   String? @map("signal_id")
  documentId String? @map("document_id")

  // The diff itself
  diffContent       String   @map("diff_content")
  summary           String?
  rationale         String?
  confidence        Decimal? @db.Decimal(3, 2)
  suspectedSections String[] @map("suspected_sections")
  sourceLinks       String[] @map("source_links")

  // Routing
  routedToUserId    String? @map("routed_to_user_id")
  routingConfidence String? @map("routing_confidence")

  // Approval state
  status         String    @default("pending")
  slackChannelId String?   @map("slack_channel_id")
  slackMessageTs String?   @map("slack_message_ts")
  snoozeUntil    DateTime? @map("snooze_until")

  // Resolution
  resolvedAt        DateTime? @map("resolved_at")
  resolvedByUserId  String?   @map("resolved_by_user_id")
  rejectionReason   String?   @map("rejection_reason")
  rejectionTags     String[]  @map("rejection_tags")
  editedDiffContent String?   @map("edited_diff_content")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  organization Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  signal       Signal?          @relation(fields: [signalId], references: [id])
  document     TrackedDocument? @relation(fields: [documentId], references: [id])
  routedTo     User?            @relation("RoutedTo", fields: [routedToUserId], references: [id])
  resolvedBy   User?            @relation("ResolvedBy", fields: [resolvedByUserId], references: [id])
  auditLogs    AuditLog[]

  @@index([orgId, status])
  @@index([routedToUserId, status])
  @@map("diff_proposals")
}

// Full audit trail
model AuditLog {
  id             String   @id @default(uuid())
  orgId          String   @map("org_id")
  action         String // 'proposal_created', 'approved', 'rejected', 'edited', 'writeback_success'
  actorUserId    String?  @map("actor_user_id")
  documentId     String?  @map("document_id")
  diffProposalId String?  @map("diff_proposal_id")
  metadata       Json     @default("{}")
  createdAt      DateTime @default(now()) @map("created_at")

  organization Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  actor        User?            @relation(fields: [actorUserId], references: [id])
  document     TrackedDocument? @relation(fields: [documentId], references: [id])
  diffProposal DiffProposal?    @relation(fields: [diffProposalId], references: [id])

  @@index([orgId, createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Metrics snapshots (for dashboard)
model MetricsSnapshot {
  id                     String   @id @default(uuid())
  orgId                  String   @map("org_id")
  date                   DateTime @db.Date
  totalSignals           Int      @default(0) @map("total_signals")
  totalProposals         Int      @default(0) @map("total_proposals")
  approvedCount          Int      @default(0) @map("approved_count")
  editedCount            Int      @default(0) @map("edited_count")
  rejectedCount          Int      @default(0) @map("rejected_count")
  snoozedCount           Int      @default(0) @map("snoozed_count")
  avgTimeToApprovalHours Decimal? @map("avg_time_to_approval_hours") @db.Decimal(10, 2)
  docsUpdatedCount       Int      @default(0) @map("docs_updated_count")
  createdAt              DateTime @default(now()) @map("created_at")

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, date])
  @@map("metrics_snapshots")
}
