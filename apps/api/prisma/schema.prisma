// Prisma schema for VertaAI
// Knowledge Drift Agent for Engineering Ops

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ======================================================================
// NEW MODELS (Phase 1: Workspace-based multi-tenancy)
// These coexist with Organization model for gradual migration
// ======================================================================

// Workspaces (new multi-tenant model - replaces Organization)
model Workspace {
  id         String @id @default(uuid())
  name       String
  slug       String @unique
  ownerEmail String @map("owner_email")

  // Ownership config (for owner resolution)
  ownershipSourceRanking String[] @default(["pagerduty", "codeowners", "manual"]) @map("ownership_source_ranking")
  defaultOwnerType       String   @default("slack_channel") @map("default_owner_type")
  defaultOwnerRef        String   @default("#engineering") @map("default_owner_ref")

  // Notification policy (confidence-based routing)
  // UPDATED: Aligned with Phase 2 systematic fixes (was 0.70/0.55, now 0.98/0.40)
  highConfidenceThreshold   Float   @default(0.98) @map("high_confidence_threshold")
  mediumConfidenceThreshold Float   @default(0.40) @map("medium_confidence_threshold")
  digestChannel             String? @map("digest_channel")

  // Workspace policy for doc resolution (per spec Section 1.1 + Section 7)
  primaryDocRequired        Boolean  @default(false) @map("primary_doc_required") // If true, fail if no primary doc mapping exists
  allowPrLinkOverride       Boolean  @default(true) @map("allow_pr_link_override") // Allow PR links to override mappings
  allowSearchSuggestMapping Boolean  @default(false) @map("allow_search_suggest_mapping") // Allow search-based suggestions (P2)
  minConfidenceForSuggest   Float    @default(0.6) @map("min_confidence_for_suggest") // Min confidence for search suggest
  allowedConfluenceSpaces   String[] @default([]) @map("allowed_confluence_spaces") // Space key allowlist (empty = allow all)

  // Workflow preferences (Phase 5 - Settings page)
  // JSON structure: { enabledDriftTypes: string[], enabledInputSources: string[], enabledOutputTargets: string[], outputTargetPriority: string[] }
  workflowPreferences Json @default("{}") @map("workflow_preferences")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  integrations          Integration[]
  signalEvents          SignalEvent[]
  driftPlans            DriftPlan[]
  planRuns              PlanRun[] // NEW: Gap #6 - Plan execution tracking
  driftCandidates       DriftCandidate[]
  driftClusters         DriftCluster[] // NEW: Gap #9 - Cluster-first drift triage
  patchProposals        PatchProposal[]
  docMappingsV2         DocMappingV2[]
  ownerMappings         OwnerMapping[]
  auditEvents           AuditEvent[]
  approvals             Approval[]
  slackQuestionClusters SlackQuestionCluster[]
  driftSuppressions     DriftSuppression[] // NEW: Phase 1 suppression system
  driftHistories        DriftHistory[] // NEW: Phase 5 temporal drift accumulation
  coverageSnapshots     CoverageSnapshot[] // NEW: Phase 3 Week 6 coverage monitoring
  auditTrails           AuditTrail[] // NEW: Phase 4 Week 8 comprehensive audit trail
  contractPacks         ContractPack[] // NEW: Contract Integrity & Readiness
  contractPolicies      ContractPolicy[] // NEW: Contract Integrity Gate policies
  policyPacks           WorkspacePolicyPack[] // NEW: P2 Unified Policy Packs

  @@map("workspaces")
}

// Integrations (OAuth connections per workspace)
model Integration {
  id            BigInt   @id @default(autoincrement())
  workspaceId   String   @map("workspace_id")
  type          String // 'github', 'pagerduty', 'slack', 'confluence', 'notion'
  status        String   @default("pending") // 'pending', 'connected', 'error', 'revoked'
  config        Json     @default("{}")
  webhookSecret String?  @map("webhook_secret")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, type])
  @@map("integrations")
}

// Signal Events (workspace-scoped, composite primary key)
model SignalEvent {
  workspaceId String   @map("workspace_id")
  id          String // eventId from source (e.g., github_pr_owner/repo_123)
  sourceType  String   @map("source_type") // 'github_pr', 'pagerduty_incident', 'slack_cluster'
  occurredAt  DateTime @map("occurred_at")
  service     String?
  repo        String?
  severity    String? // 'sev1', 'sev2', 'sev3', 'sev4'
  extracted   Json     @default("{}")
  rawPayload  Json     @map("raw_payload")
  createdAt   DateTime @default(now()) @map("created_at")

  // NEW: For incident-based signals (Phase 3)
  incidentId  String?  @map("incident_id")
  incidentUrl String?  @map("incident_url")
  responders  String[] @default([])

  // NEW: For Slack-based signals (Phase 4)
  slackClusterId String? @map("slack_cluster_id")
  messageCount   Int?    @map("message_count")

  workspace            Workspace              @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  driftCandidates      DriftCandidate[]
  contractResolutions  ContractResolution[] // NEW: Contract Integrity & Readiness

  @@id([workspaceId, id])
  @@index([workspaceId, sourceType, occurredAt(sort: Desc)])
  @@index([workspaceId, service, occurredAt(sort: Desc)])
  @@map("signal_events")
}

// Drift Candidates (state machine entity)
model DriftCandidate {
  workspaceId   String @map("workspace_id")
  id            String @default(uuid())
  signalEventId String @map("signal_event_id")

  // State machine (18 states)
  state          String   @default("INGESTED") // DriftState enum
  stateUpdatedAt DateTime @default(now()) @map("state_updated_at")

  // Source context
  sourceType String  @map("source_type")
  service    String?
  repo       String?

  // Drift classification
  driftType       String?  @map("drift_type") // 'instruction', 'process', 'ownership', 'coverage', 'environment_tooling'
  driftDomains    String[] @map("drift_domains")
  hasCoverageGap  Boolean  @default(false) @map("has_coverage_gap") // Gap #2: Coverage as orthogonal dimension - can be true for ANY drift type

  // Phase 1 Day 1: Deterministic drift classification
  comparisonResult      Json?    @map("comparison_result")       // Complete comparison result from deterministic comparison
  classificationMethod  String?  @map("classification_method")   // 'deterministic' | 'llm' - which method was used
  llmDriftType          String?  @map("llm_drift_type")          // Original LLM classification (for audit trail)
  llmConfidence         Float?   @map("llm_confidence")          // Original LLM confidence (for audit trail)

  // Evidence & scoring
  evidenceSummary   String? @map("evidence_summary")
  confidence        Float?
  driftScore        Float?  @map("drift_score")
  riskLevel         String? @map("risk_level") // 'low', 'medium', 'high'
  recommendedAction String? @map("recommended_action") // 'generate_patch', 'annotate_only', 'review_queue', 'ignore'

  // Drift Verdict (Phase 1 Quick Win - Comparison-based verdict)
  // Stores the explicit comparison-based drift decision
  driftVerdict Json? @map("drift_verdict") // { hasMatch: boolean, confidence: number, source: string, evidence: string[], comparisonType: string }

  // NEW: Evidence Bundle (Phase 1 - Truth-making system)
  // Complete deterministic evidence bundle for reproducible decisions
  evidenceBundle Json? @map("evidence_bundle")

  // NEW: Impact Assessment (Phase 1 - Multi-source impact)
  impactScore        Float?  @map("impact_score")        // 0-1 scale
  impactBand         String? @map("impact_band")         // 'low', 'medium', 'high', 'critical'
  impactJson         Json?   @map("impact_json")         // Complete impact assessment details
  consequenceText    String? @map("consequence_text")    // Human-readable consequence
  impactAssessedAt   DateTime? @map("impact_assessed_at") // When impact was assessed

  // NEW: Fingerprints for suppression (Phase 1 - Fatigue reduction)
  fingerprintStrict  String? @map("fingerprint_strict")  // Exact match fingerprint
  fingerprintMedium  String? @map("fingerprint_medium")  // Normalized token fingerprint
  fingerprintBroad   String? @map("fingerprint_broad")   // High-level pattern fingerprint

  // Document targeting
  docCandidates    Json     @default("[]") @map("doc_candidates")
  baselineFindings Json     @default("[]") @map("baseline_findings")
  targetDocSystems String[] @default([]) @map("target_doc_systems") // Multi-source enrichment: allowed doc systems for this source+drift combo

  // Doc resolution tracking (per spec Section C)
  docsResolutionStatus     String? @map("docs_resolution_status") // 'mapped' | 'explicit_link' | 'search_candidate' | 'needs_mapping' | 'ignored'
  docsResolutionMethod     String? @map("docs_resolution_method") // 'mapping' | 'pr_link' | 'confluence_search' | 'none'
  docsResolutionConfidence Float?  @map("docs_resolution_confidence")
  noWritebackMode          Boolean @default(false) @map("no_writeback_mode") // Set when writeback should be skipped

  // Selected doc details (per spec Section 0.1)
  selectedDocId    String? @map("selected_doc_id")
  selectedDocUrl   String? @map("selected_doc_url")
  selectedDocTitle String? @map("selected_doc_title")

  // Idempotency + debuggability fields (per spec Section 0.1)
  // Black box flight recorder - full DocResolutionResult blob for debugging resolution steps
  docsResolution   Json?   @map("docs_resolution")
  // DocContext snapshot - for LLM call reproducibility
  docContext       Json?   @map("doc_context")
  // Confluence version at fetch time - for detecting concurrent edits
  baseRevision     String? @map("base_revision")
  // Stable fingerprint of context slice - for cache/dedup
  docContextSha256 String? @map("doc_context_sha256")

  // Owner resolution
  ownerResolution Json? @map("owner_resolution")

  // Deduplication (fingerprint = hash of workspace + service + drift_type + domains + doc_id + key_tokens)
  fingerprint String?

  // Needs-mapping notification deduplication (per spec Section 7)
  // Key format: "workspace_id:repo" - used to prevent spam for same repo
  needsMappingKey        String?   @map("needs_mapping_key")
  needsMappingNotifiedAt DateTime? @map("needs_mapping_notified_at")

  // Correlated signals (from SignalJoiner - Phase 4)
  correlatedSignals Json    @default("[]") @map("correlated_signals")
  correlationBoost  Float   @default(0) @map("correlation_boost")
  correlationReason String? @map("correlation_reason")

  // Multi-source enrichment metadata (Points 2-10)
  patchStyle             String? @map("patch_style") // Point 6: Output-specific patch style
  sectionPattern         String? @map("section_pattern") // Point 4: Target section pattern
  sourceConfidenceWeight Float?  @map("source_confidence_weight") // Point 5: Source-specific confidence weight
  preValidationPassed    Boolean @default(true) @map("pre_validation_passed") // Point 7: Pre-validation result
  sourceThreshold        Float?  @map("source_threshold") // Point 8: Source-specific threshold
  correlationScore       Float?  @map("correlation_score") // Point 9: Cross-source correlation score

  // Error tracking
  lastErrorCode    String? @map("last_error_code")
  lastErrorMessage String? @map("last_error_message")
  retryCount       Int     @default(0) @map("retry_count")

  // Observability (Phase 4)
  traceId String? @map("trace_id") // End-to-end trace ID for logging and debugging

  // Plan tracking (Gap #6: DriftPlan as True Control-Plane)
  activePlanId      String? @map("active_plan_id")      // Which plan was active when this drift was processed
  activePlanVersion Int?    @map("active_plan_version") // Plan version at processing time
  activePlanHash    String? @map("active_plan_hash")    // Plan hash for reproducibility

  // Cluster tracking (Gap #9: Cluster-First Drift Triage)
  clusterId String? @map("cluster_id") // Which cluster this drift belongs to (null if individual notification)

  createdAt DateTime @default(now()) @map("created_at")

  workspace         Workspace           @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  signalEvent       SignalEvent         @relation(fields: [workspaceId, signalEventId], references: [workspaceId, id], onDelete: Cascade)
  cluster           DriftCluster?       @relation(fields: [workspaceId, clusterId], references: [workspaceId, id], onDelete: SetNull)
  patchProposals    PatchProposal[]
  integrityFindings IntegrityFinding[] // NEW: Contract Integrity & Readiness

  @@id([workspaceId, id])
  @@unique([workspaceId, fingerprint])
  @@index([workspaceId, state, stateUpdatedAt(sort: Desc)])
  @@index([workspaceId, service])
  @@index([workspaceId, needsMappingKey, needsMappingNotifiedAt])
  @@index([traceId])
  @@map("drift_candidates")
}

// ======================================================================
// DRIFT CLUSTER (Gap #9: Cluster-First Drift Triage)
// Aggregates similar drifts to reduce notification fatigue
// ======================================================================

model DriftCluster {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Cluster key (used for grouping similar drifts)
  service            String  // Service name (e.g., 'api-service', 'web-app')
  driftType          String  @map("drift_type") // 'instruction', 'process', 'ownership', 'coverage', 'environment'
  fingerprintPattern String  @map("fingerprint_pattern") // High-level pattern (e.g., 'kubectl-command', 'deployment-steps')

  // Cluster metadata
  status     String   @default("pending") // 'pending', 'notified', 'closed'
  driftCount Int      @default(0) @map("drift_count") // Number of drifts in this cluster
  createdAt  DateTime @default(now()) @map("created_at")
  closedAt   DateTime? @map("closed_at") // When cluster was closed (after notification or expiry)
  notifiedAt DateTime? @map("notified_at") // When cluster notification was sent

  // Slack notification tracking
  slackMessageTs String? @map("slack_message_ts") // Slack message timestamp (for updates)
  slackChannel   String? @map("slack_channel") // Slack channel where notification was sent

  // Cluster summary (for Slack message)
  clusterSummary String? @map("cluster_summary") @db.Text // Human-readable summary of cluster
  driftIds       String[] @default([]) @map("drift_ids") // Array of drift IDs in this cluster

  // Bulk action tracking
  bulkActionStatus String? @map("bulk_action_status") // 'approved', 'rejected', 'snoozed', null
  bulkActionAt     DateTime? @map("bulk_action_at") // When bulk action was taken
  bulkActionBy     String? @map("bulk_action_by") // User who took bulk action

  // Relations
  workspace Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  drifts    DriftCandidate[]

  // Composite unique constraint: one active cluster per {workspace, service, driftType, pattern}
  // This ensures we don't create duplicate clusters for the same drift pattern
  @@unique([workspaceId, service, driftType, fingerprintPattern, status], name: "unique_active_cluster")
  @@id([workspaceId, id])
  @@index([workspaceId, status])
  @@index([workspaceId, service])
  @@index([createdAt])
  @@index([notifiedAt])
  @@map("drift_clusters")
}

// Patch Proposals (generated patches awaiting approval)
model PatchProposal {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  driftId     String @map("drift_id")

  // Target document
  docSystem String  @map("doc_system") // 'confluence', 'notion'
  docId     String  @map("doc_id")
  docTitle  String  @map("doc_title")
  docUrl    String? @map("doc_url")

  // Patch content
  baseRevision String? @map("base_revision")
  patchStyle   String  @default("replace_steps") @map("patch_style") // 'replace_steps', 'add_note', 'reorder_steps', 'update_owner_block', 'add_section', 'link_patch'
  unifiedDiff  String  @map("unified_diff") @db.Text

  // Metadata
  sourcesUsed Json    @default("[]") @map("sources_used")
  confidence  Float   @default(0)
  summary     String?

  // Validation
  validatorReport Json @default("{}") @map("validator_report")

  // Status
  status String @default("proposed") // 'proposed', 'sent', 'approved', 'edited', 'rejected', 'snoozed', 'written_back'

  // Slack tracking
  slackChannel String? @map("slack_channel")
  slackTs      String? @map("slack_ts")

  // Notification tracking
  lastNotifiedAt    DateTime? @map("last_notified_at")
  notificationCount Int       @default(0) @map("notification_count")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace      Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  driftCandidate DriftCandidate @relation(fields: [workspaceId, driftId], references: [workspaceId, id], onDelete: Cascade)
  approvals      Approval[]

  @@id([workspaceId, id])
  @@index([workspaceId, docSystem, docId])
  @@index([workspaceId, status, updatedAt(sort: Desc)])
  @@map("patch_proposals")
}

// NEW: Drift Suppression Model (Phase 1 - Fatigue reduction)
model DriftSuppression {
  workspaceId        String   @map("workspace_id")
  id                 String   @default(cuid()) @map("id")
  fingerprint        String   @map("fingerprint")
  fingerprintLevel   String   @map("fingerprint_level") // 'strict', 'medium', 'broad'
  suppressionType    String   @map("suppression_type")  // 'false_positive', 'snooze', 'permanent'
  reason             String?  @map("reason")
  createdBy          String?  @map("created_by")
  expiresAt          DateTime? @map("expires_at")
  falsePositiveCount Int      @default(0) @map("false_positive_count")
  lastSeenAt         DateTime? @map("last_seen_at")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@unique([workspaceId, fingerprint])
  @@index([workspaceId, fingerprint])
  @@index([workspaceId, expiresAt])
  @@map("drift_suppressions")
}

// NEW: Drift History Model (Phase 5 - Temporal drift accumulation)
// Tracks cumulative drift per document over time windows
model DriftHistory {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Document tracking
  docSystem String @map("doc_system") // 'confluence', 'notion', 'github', etc.
  docId     String @map("doc_id")
  docTitle  String @map("doc_title")

  // Time window tracking
  windowStart DateTime @map("window_start") // Start of accumulation window
  windowEnd   DateTime @map("window_end")   // End of accumulation window (null = active)

  // Accumulation metrics
  driftCount          Int      @default(0) @map("drift_count")           // Number of drifts in this window
  skippedDriftCount   Int      @default(0) @map("skipped_drift_count")   // Number of low-materiality drifts skipped
  totalMateriality    Float    @default(0) @map("total_materiality")     // Sum of materiality scores
  averageMateriality  Float    @default(0) @map("average_materiality")   // Average materiality score

  // Drift type breakdown (JSON array of {driftType, count})
  driftTypeBreakdown Json @default("[]") @map("drift_type_breakdown")

  // Accumulated drift IDs for bundling
  accumulatedDriftIds String[] @map("accumulated_drift_ids")

  // Bundling status
  status          String    @default("accumulating") // 'accumulating', 'bundled', 'expired'
  bundledAt       DateTime? @map("bundled_at")       // When drifts were bundled
  bundledDriftId  String?   @map("bundled_drift_id") // ID of the bundled drift candidate
  bundleTrigger   String?   @map("bundle_trigger")   // 'threshold_reached', 'manual', 'window_expired'

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@unique([workspaceId, docSystem, docId, windowStart], name: "unique_doc_window")
  @@index([workspaceId, docSystem, docId, status])
  @@index([workspaceId, status, windowEnd])
  @@map("drift_histories")
}

// Approvals (append-only audit log for human actions)
model Approval {
  workspaceId       String    @map("workspace_id")
  id                String    @default(uuid())
  patchId           String    @map("patch_id")
  action            String // 'approve', 'edit', 'reject', 'snooze'
  actorSlackId      String    @map("actor_slack_id")
  actorName         String?   @map("actor_name")
  note              String?
  editedDiff        String?   @map("edited_diff") @db.Text
  snoozeUntil       DateTime? @map("snooze_until")
  rejectionCategory String?   @map("rejection_category")
  createdAt         DateTime  @default(now()) @map("created_at")

  workspace     Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  patchProposal PatchProposal @relation(fields: [workspaceId, patchId], references: [workspaceId, id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, patchId, createdAt(sort: Desc)])
  @@map("approvals")
}

// Doc Mappings V2 (with primary doc flag and managed region tracking)
model DocMappingV2 {
  workspaceId              String    @map("workspace_id")
  id                       BigInt    @id @default(autoincrement())
  service                  String?
  repo                     String?
  docSystem                String    @map("doc_system") // 'confluence', 'notion', 'github_readme', 'github_swagger', 'backstage'
  docId                    String    @map("doc_id")
  docTitle                 String    @map("doc_title")
  docUrl                   String?   @map("doc_url")
  spaceKey                 String?   @map("space_key") // Confluence space key for doc resolution
  isPrimary                Boolean   @default(false) @map("is_primary")
  hasManagedRegion         Boolean   @default(false) @map("has_managed_region")
  managedRegionInstalledAt DateTime? @map("managed_region_installed_at")
  docClass                 String?   @map("doc_class") // e.g., 'Operational_Runbook', 'Architecture_Doc', 'API_Reference'
  allowWriteback           Boolean   @default(true) @map("allow_writeback") // Per spec: controls if writeback is allowed for this mapping
  createdAt                DateTime  @default(now()) @map("created_at")
  updatedAt                DateTime  @updatedAt @map("updated_at")

  // NEW: Multi-source fields (Phase 1)
  docCategory       String?  @map("doc_category") // 'functional' | 'developer' | 'operational'
  filePath          String?  @map("file_path") // For GitHub-based docs: "README.md", "docs/api.yaml"
  driftTypeAffinity String[] @default([]) @map("drift_type_affinity") // Drift types this doc is relevant for
  sourceType        String?  @map("source_type") // 'github_pr' | 'pagerduty_incident' | 'slack_cluster' | etc. NULL = applies to all sources

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, docSystem, docId])
  @@index([workspaceId, service])
  @@index([workspaceId, repo])
  @@index([workspaceId, docCategory])
  @@index([workspaceId, repo, sourceType])
  @@map("doc_mappings_v2")
}

// Owner Mappings (service/repo to owner resolution)
model OwnerMapping {
  workspaceId String   @map("workspace_id")
  id          BigInt   @id @default(autoincrement())
  service     String?
  repo        String?
  ownerType   String   @map("owner_type") // 'slack_user', 'slack_channel', 'team'
  ownerRef    String   @map("owner_ref")
  source      String   @default("manual") // 'manual', 'pagerduty', 'codeowners', 'commit_history'
  createdAt   DateTime @default(now()) @map("created_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, service])
  @@index([workspaceId, repo])
  @@map("owner_mappings")
}

// Audit Events (system-wide event log)
model AuditEvent {
  workspaceId String   @map("workspace_id")
  id          BigInt   @id @default(autoincrement())
  entityType  String   @map("entity_type") // 'signal', 'drift', 'patch', 'approval', 'writeback', 'integration'
  entityId    String   @map("entity_id")
  eventType   String   @map("event_type")
  payload     Json     @default("{}")
  actorType   String?  @map("actor_type") // 'system', 'user', 'webhook'
  actorId     String?  @map("actor_id")
  createdAt   DateTime @default(now()) @map("created_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, entityType, entityId, createdAt(sort: Desc)])
  @@index([workspaceId, createdAt(sort: Desc)])
  @@map("audit_events")
}

// ======================================================================
// CONTRACT INTEGRITY & READINESS (Phase 1: API Contract MVP)
// Contract validation and artifact snapshot system
// ======================================================================

// Contract Pack (workspace-level contract configuration)
model ContractPack {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  version     String @default("v1")
  name        String
  description String?

  // JSON blob for now, can normalize later
  contracts    Json @default("[]") // Array<Contract>
  dictionaries Json @default("{}") // Service aliases, glossary
  extraction   Json @default("{}") // Token limits, truncation
  safety       Json @default("{}") // Secret patterns, immutable sections

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId])
  @@map("contract_packs")
}

// ======================================================================
// P2: UNIFIED WORKSPACE POLICY PACK (Week 7-10)
// Combines Track A (Contract Integrity) + Track B (Drift Remediation)
// ======================================================================

model WorkspacePolicyPack {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Metadata
  name        String
  description String?
  status      String @default("active")  // 'active', 'draft', 'archived'

  // Scope (shared by both tracks)
  scopeType String   // 'workspace', 'service', 'repo'
  scopeRef  String?  @map("scope_ref") // service ID or repo full name

  // Scope filters
  repoAllowlist String[] @default([]) @map("repo_allowlist")  // ['owner/repo1', 'owner/repo2']
  pathGlobs     String[] @default([]) @map("path_globs")      // ['openapi.yaml', 'src/**/*.ts']

  // Track A: Contract Integrity Gate
  trackAEnabled Boolean @default(false) @map("track_a_enabled")
  trackAConfig  Json @default("{}") @map("track_a_config")
  // Structure: {
  //   surfaces: ['api', 'infra', 'docs'],
  //   contracts: [{ contractId, name, description, scope, artifacts, invariants, enforcement, routing, writeback }],
  //   dictionaries: { serviceAliases: {}, glossary: {} },
  //   extraction: { tokenLimits: {}, truncation: {} },
  //   safety: { secretPatterns: [], immutableSections: [] },
  //   enforcement: { mode: 'warn', criticalThreshold: 90, highThreshold: 70, mediumThreshold: 40 },
  //   gracefulDegradation: { timeoutMs: 30000, fallbackMode: 'warn' },
  //   appliesTo: [{ type: 'surface', value: 'api' }]
  // }

  // Track B: Drift + Remediation
  trackBEnabled Boolean @default(false) @map("track_b_enabled")
  trackBConfig  Json @default("{}") @map("track_b_config")
  // Structure: {
  //   primaryDoc: { system: 'confluence', id: '123', title: 'Runbook', url: '', class: 'runbook' },
  //   inputSources: [{ type: 'github_pr', enabled: true, config: {} }],
  //   driftTypes: [{ type: 'instruction', enabled: true, sectionTarget: 'Deployment Steps' }],
  //   materiality: { autoApprove: 0.98, slackNotify: 0.40, digestOnly: 0.30, ignore: 0.20 },
  //   docTargeting: { strategy: 'primary_first', maxDocsPerDrift: 3 },
  //   noiseControls: { ignorePatterns: [], ignorePaths: [], temporalAccumulation: { enabled: true, windowDays: 7 } },
  //   allowedOutputs: ['confluence', 'notion', 'github_readme']
  // }

  // Shared: Approval & Routing
  approvalTiers Json @default("{}") @map("approval_tiers")
  // Structure: {
  //   tier1: { name: 'Team Lead', users: ['alice@example.com'], teams: ['@acme/team-leads'], requiredFor: ['medium', 'high', 'critical'] },
  //   tier2: { name: 'Director', users: ['bob@example.com'], teams: ['@acme/directors'], requiredFor: ['high', 'critical'] },
  //   tier3: { name: 'CTO', users: ['cto@example.com'], teams: ['@acme/executives'], requiredFor: ['critical'] }
  // }

  routing Json @default("{}") @map("routing")
  // Structure: {
  //   slackChannel: '#platform',
  //   emailList: ['team@example.com'],
  //   pagerDutyService: 'P123456'
  // }

  // Shared: Test Mode
  testMode Boolean @default(false) @map("test_mode")
  testModeConfig Json @default("{}") @map("test_mode_config")
  // Structure: {
  //   enabled: true,
  //   dryRun: true,
  //   previewFindings: true,
  //   notifyOnTest: false
  // }

  // Versioning
  version     Int    @default(1)
  versionHash String @map("version_hash")
  parentId    String? @map("parent_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String? @map("created_by")
  updatedBy String? @map("updated_by")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId])
  @@index([status])
  @@index([workspaceId, status])
  @@map("workspace_policy_packs")
}

// Contract Policy (workspace-level enforcement policy)
// Defines how contract violations should be handled
model ContractPolicy {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  name        String
  description String?

  // Enforcement mode
  // - 'warn_only': All violations create warnings, never block
  // - 'block_high_critical': Block on high/critical, warn on medium/low
  // - 'block_all_critical': Block only on critical, warn on all others
  mode String @default("warn_only")

  // Severity thresholds (0-100 scale)
  criticalThreshold Int @default(90) @map("critical_threshold") // >= 90 = critical
  highThreshold     Int @default(70) @map("high_threshold") // >= 70 = high
  mediumThreshold   Int @default(40) @map("medium_threshold") // >= 40 = medium
  // < 40 = low

  // Graceful degradation settings
  gracefulDegradation Json @default("{}") @map("graceful_degradation")
  // Structure: {
  //   "timeoutMs": 30000,
  //   "maxArtifactFetchFailures": 3,
  //   "fallbackMode": "warn_only",
  //   "enableSoftFail": true
  // }

  // Policy application
  appliesTo Json @default("[]") @map("applies_to")
  // Structure: Array<{
  //   "type": "surface" | "repo" | "service",
  //   "value": "api" | "owner/repo" | "service-name"
  // }>

  // Active status
  active Boolean @default(true)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId])
  @@index([workspaceId, active])
  @@map("contract_policies")
}

// Contract Resolution Result (audit trail)
model ContractResolution {
  workspaceId   String @map("workspace_id")
  id            String @default(uuid())
  signalEventId String @map("signal_event_id")

  // What contracts were resolved
  resolvedContracts   Json @default("[]") @map("resolved_contracts") // Array<{contractId, method, confidence, triggeredBy}>
  unresolvedArtifacts Json @default("[]") @map("unresolved_artifacts") // Array<{file, reason, candidates}>
  obligations         Json @default("[]") // Array<{type, artifact, suggestedAction}>

  // Resolution metadata
  resolutionMethod String @map("resolution_method") // 'explicit_mapping' | 'file_pattern' | 'search'
  resolutionTimeMs Int    @map("resolution_time_ms")

  createdAt DateTime @default(now()) @map("created_at")

  signalEvent SignalEvent @relation(fields: [workspaceId, signalEventId], references: [workspaceId, id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, signalEventId])
  @@map("contract_resolutions")
}

// Artifact Snapshot (versioned artifact extracts)
model ArtifactSnapshot {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  contractId  String @map("contract_id")

  // Artifact identity
  artifactType String @map("artifact_type") // 'openapi' | 'confluence_page' | 'runbook' | etc.
  artifactRef  Json   @map("artifact_ref") // {system, locator, role}

  // Version tracking
  version Json @map("version") // {type, value, capturedAt}

  // Structured extract (not raw content)
  extract       Json   @map("extract") // Type-specific structured data
  extractSchema String @map("extract_schema") // Schema version for extract

  // Provenance
  triggeredBy Json @map("triggered_by") // {signalEventId?, prNumber?, scheduledJobId?}

  // Storage optimization
  ttlDays    Int     @default(30) @map("ttl_days")
  compressed Boolean @default(false)
  sizeBytes  Int     @map("size_bytes")

  createdAt DateTime @default(now()) @map("created_at")

  @@id([workspaceId, id])
  @@index([workspaceId, contractId])
  @@index([workspaceId, artifactType])
  @@index([createdAt]) // For TTL cleanup
  @@map("artifact_snapshots")
}

// Integrity Finding (deterministic comparison result)
model IntegrityFinding {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  contractId  String @map("contract_id")
  invariantId String @map("invariant_id")

  // Classification (deterministic)
  driftType String   @map("drift_type") // 'instruction' | 'process' | 'ownership' | 'coverage' | 'environment_tooling'
  domains   String[] @default([])
  severity  String // 'low' | 'medium' | 'high' | 'critical'

  // Comparison metadata
  compared Json @map("compared") // {left: {artifact, snapshotId}, right: {artifact, snapshotId}}
  evidence Json @default("[]") // Array<{kind, leftValue, rightValue, pointers}>

  // Scores (deterministic)
  confidence Float
  impact     Float
  band       String // 'pass' | 'warn' | 'fail'

  // Routing
  recommendedAction String @map("recommended_action") // 'no_action' | 'notify' | 'create_patch_candidate' | 'block_merge'
  ownerRouting      Json   @default("{}") @map("owner_routing") // {method, owners}

  // Link to drift candidate (if remediation triggered)
  driftCandidateId String? @map("drift_candidate_id")

  createdAt DateTime @default(now()) @map("created_at")

  driftCandidate DriftCandidate? @relation(fields: [workspaceId, driftCandidateId], references: [workspaceId, id], onDelete: SetNull)

  @@id([workspaceId, id])
  @@index([workspaceId, contractId])
  @@index([workspaceId, band])
  @@index([createdAt])
  @@map("integrity_findings")
}

// ======================================================================
// LEGACY MODELS (kept for gradual migration)
// Will be removed after data migration to new models is complete
// ======================================================================

// Multi-tenant organizations (LEGACY - use Workspace instead)
model Organization {
  id                    String   @id @default(uuid())
  name                  String
  slackWorkspaceId      String?  @unique @map("slack_workspace_id")
  slackBotToken         String?  @map("slack_bot_token")
  slackTeamName         String?  @map("slack_team_name")
  confluenceCloudId     String?  @map("confluence_cloud_id")
  confluenceAccessToken String?  @map("confluence_access_token")
  githubInstallationId  BigInt?  @map("github_installation_id")
  settings              Json     @default("{}")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  users            User[]
  trackedDocuments TrackedDocument[]
  docMappings      DocMapping[]
  signals          Signal[]
  diffProposals    DiffProposal[]
  auditLogs        AuditLog[]
  metricsSnapshots MetricsSnapshot[]

  @@map("organizations")
}

// Users (Slack-based identity)
model User {
  id             String   @id @default(uuid())
  orgId          String   @map("org_id")
  slackUserId    String   @map("slack_user_id")
  email          String?
  name           String?
  githubUsername String?  @map("github_username")
  isAdmin        Boolean  @default(false) @map("is_admin")
  createdAt      DateTime @default(now()) @map("created_at")

  organization      Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  ownedDocuments    TrackedDocument[] @relation("DocumentOwner")
  routedProposals   DiffProposal[]    @relation("RoutedTo")
  resolvedProposals DiffProposal[]    @relation("ResolvedBy")
  auditLogs         AuditLog[]

  @@unique([orgId, slackUserId])
  @@map("users")
}

// Docs we're actively monitoring
model TrackedDocument {
  id                  String    @id @default(uuid())
  orgId               String    @map("org_id")
  confluencePageId    String    @map("confluence_page_id")
  title               String
  contentHash         String?   @map("content_hash")
  lastContentSnapshot String?   @map("last_content_snapshot") @db.Text
  lastSyncedAt        DateTime? @map("last_synced_at")
  freshnessScore      Decimal   @default(1.0) @map("freshness_score") @db.Decimal(3, 2)
  ownerUserId         String?   @map("owner_user_id")
  ownerSource         String?   @map("owner_source")
  repoMapping         String[]  @map("repo_mapping")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  organization  Organization   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  owner         User?          @relation("DocumentOwner", fields: [ownerUserId], references: [id])
  docMappings   DocMapping[]
  diffProposals DiffProposal[]
  auditLogs     AuditLog[]

  @@unique([orgId, confluencePageId])
  @@index([orgId])
  @@map("tracked_documents")
}

// Service/repo to doc mapping
model DocMapping {
  id           String   @id @default(uuid())
  orgId        String   @map("org_id")
  repoFullName String   @map("repo_full_name")
  pathPatterns String[] @map("path_patterns")
  serviceName  String?  @map("service_name")
  documentId   String   @map("document_id")
  createdAt    DateTime @default(now()) @map("created_at")

  organization Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  document     TrackedDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([orgId, repoFullName, documentId])
  @@map("doc_mappings")
}

// Incoming signals (GitHub PRs for MVP)
model Signal {
  id            String    @id @default(uuid())
  orgId         String    @map("org_id")
  type          String // 'github_pr', 'pagerduty_incident', 'slack_question'
  externalId    String    @map("external_id")
  repoFullName  String?   @map("repo_full_name")
  payload       Json
  driftAnalysis Json?     @map("drift_analysis")
  processedAt   DateTime? @map("processed_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  organization  Organization   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  diffProposals DiffProposal[]

  @@unique([orgId, type, externalId])
  @@index([orgId, createdAt(sort: Desc)])
  @@map("signals")
}

// Generated diff proposals
model DiffProposal {
  id         String  @id @default(uuid())
  orgId      String  @map("org_id")
  signalId   String? @map("signal_id")
  documentId String? @map("document_id")

  // The diff itself
  diffContent       String   @map("diff_content")
  summary           String?
  rationale         String?
  confidence        Decimal? @db.Decimal(3, 2)
  suspectedSections String[] @map("suspected_sections")
  sourceLinks       String[] @map("source_links")

  // Routing
  routedToUserId    String? @map("routed_to_user_id")
  routingConfidence String? @map("routing_confidence")

  // Approval state
  status         String    @default("pending")
  slackChannelId String?   @map("slack_channel_id")
  slackMessageTs String?   @map("slack_message_ts")
  snoozeUntil    DateTime? @map("snooze_until")

  // Resolution
  resolvedAt        DateTime? @map("resolved_at")
  resolvedByUserId  String?   @map("resolved_by_user_id")
  rejectionReason   String?   @map("rejection_reason")
  rejectionTags     String[]  @map("rejection_tags")
  editedDiffContent String?   @map("edited_diff_content")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  organization Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  signal       Signal?          @relation(fields: [signalId], references: [id])
  document     TrackedDocument? @relation(fields: [documentId], references: [id])
  routedTo     User?            @relation("RoutedTo", fields: [routedToUserId], references: [id])
  resolvedBy   User?            @relation("ResolvedBy", fields: [resolvedByUserId], references: [id])
  auditLogs    AuditLog[]

  @@index([orgId, status])
  @@index([routedToUserId, status])
  @@map("diff_proposals")
}

// Full audit trail
model AuditLog {
  id             String   @id @default(uuid())
  orgId          String   @map("org_id")
  action         String // 'proposal_created', 'approved', 'rejected', 'edited', 'writeback_success'
  actorUserId    String?  @map("actor_user_id")
  documentId     String?  @map("document_id")
  diffProposalId String?  @map("diff_proposal_id")
  metadata       Json     @default("{}")
  createdAt      DateTime @default(now()) @map("created_at")

  organization Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  actor        User?            @relation(fields: [actorUserId], references: [id])
  document     TrackedDocument? @relation(fields: [documentId], references: [id])
  diffProposal DiffProposal?    @relation(fields: [diffProposalId], references: [id])

  @@index([orgId, createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Metrics snapshots (for dashboard)
model MetricsSnapshot {
  id                     String   @id @default(uuid())
  orgId                  String   @map("org_id")
  date                   DateTime @db.Date
  totalSignals           Int      @default(0) @map("total_signals")
  totalProposals         Int      @default(0) @map("total_proposals")
  approvedCount          Int      @default(0) @map("approved_count")
  editedCount            Int      @default(0) @map("edited_count")
  rejectedCount          Int      @default(0) @map("rejected_count")
  snoozedCount           Int      @default(0) @map("snoozed_count")
  avgTimeToApprovalHours Decimal? @map("avg_time_to_approval_hours") @db.Decimal(10, 2)
  docsUpdatedCount       Int      @default(0) @map("docs_updated_count")
  createdAt              DateTime @default(now()) @map("created_at")

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, date])
  @@map("metrics_snapshots")
}

// Slack Question Clusters (Phase 4: Knowledge Gap Detection)
model SlackQuestionCluster {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())
  channelId   String @map("channel_id")
  channelName String @map("channel_name")

  // Cluster metadata
  representativeQuestion String   @map("representative_question")
  topic                  String   @default("general")
  messageCount           Int      @map("message_count")
  uniqueAskers           Int      @map("unique_askers")
  firstSeen              DateTime @map("first_seen")
  lastSeen               DateTime @map("last_seen")

  // Processing state
  processedAt   DateTime? @map("processed_at")
  signalEventId String?   @map("signal_event_id")

  // Raw data
  sampleMessages Json @map("sample_messages")

  // Similarity scoring
  avgSimilarity Float @default(0) @map("avg_similarity")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, lastSeen(sort: Desc)])
  @@index([workspaceId, processedAt])
  @@map("slack_question_clusters")
}

// ======================================================================
// DRIFT PLAN (Phase 3: Control-Plane Architecture)
// Versioned plans for reproducible drift detection and remediation
// ======================================================================

model DriftPlan {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Plan metadata
  name        String
  description String?
  status      String @default("active") // 'active', 'archived', 'draft'

  // Scope definition (5-step resolution hierarchy)
  scopeType String // 'workspace', 'service', 'repo'
  scopeRef  String? // service ID or repo full name (null for workspace scope)

  // Primary documentation target
  primaryDocId     String? @map("primary_doc_id") // Doc ID in the doc system
  primaryDocSystem String? @map("primary_doc_system") // 'confluence', 'notion', 'github_readme', etc.
  docClass         String? @map("doc_class") // 'runbook', 'api_contract', 'service_catalog', etc.

  // Plan configuration
  inputSources   String[] @default([]) @map("input_sources") // Allowed source types: ['github_pr', 'pagerduty_incident', ...]
  driftTypes     String[] @default([]) @map("drift_types") // Allowed drift types: ['instruction', 'process', ...]
  allowedOutputs String[] @default([]) @map("allowed_outputs") // Allowed output targets: ['confluence', 'notion', ...]

  // Plan rules and thresholds (JSON for flexibility)
  thresholds     Json @default("{}") // { autoApprove: 0.98, slackNotify: 0.40, digestOnly: 0.30, ignore: 0.20 }
  eligibility    Json @default("{}") // { requiresIncident: false, minSeverity: 'sev3', ... }
  sectionTargets Json @default("{}") // { instruction: 'Deployment Steps', process: 'Runbook', ... }
  impactRules    Json @default("{}") // Custom impact rules for this plan
  writeback      Json @default("{}") // { enabled: true, requiresApproval: false, ... }

  // Gap #6 Part 2: Control-Plane Fields
  docTargeting   Json @default("{}") @map("doc_targeting") // { strategy: 'primary_first' | 'all_parallel', maxDocsPerDrift: 3, priorityOrder: ['confluence', 'notion'] }
  sourceCursors  Json @default("{}") @map("source_cursors") // { github_pr: { lastProcessedAt: '2024-01-01T00:00:00Z', lastPrNumber: 123 }, ... }
  budgets        Json @default("{}") // { maxDriftsPerDay: 50, maxDriftsPerWeek: 200, maxSlackNotificationsPerHour: 5 }
  noiseControls  Json @default("{}") @map("noise_controls") // { ignorePatterns: ['WIP:', 'draft:'], ignorePaths: ['test/**'], ignoreAuthors: ['bot'] }

  // Versioning for reproducibility
  version     Int    @default(1) // Incremented on each update
  versionHash String @map("version_hash") // SHA-256 hash of plan content for reproducibility
  parentId    String? @map("parent_id") // Reference to previous version (for version history)

  // Template reference (if created from template)
  templateId   String? @map("template_id") // Reference to template used
  templateName String? @map("template_name") // Template name for display

  // Audit trail
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by") // User email or ID
  updatedBy String?  @map("updated_by") // User email or ID

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@unique([workspaceId, versionHash]) // Ensure unique content hashes per workspace
  @@index([workspaceId, status])
  @@index([workspaceId, scopeType, scopeRef])
  @@index([workspaceId, templateId])
  @@map("drift_plans")
}

// ======================================================================
// PLAN RUN TRACKING (Gap #6: DriftPlan as True Control-Plane)
// Tracks which drifts were processed under which plan version
// ======================================================================

model PlanRun {
  workspaceId String @map("workspace_id")
  id          String @default(uuid())

  // Plan reference
  planId      String @map("plan_id")
  planVersion Int    @map("plan_version") // Snapshot of plan version at execution time
  planHash    String @map("plan_hash") // Snapshot of plan hash for reproducibility

  // Drift reference
  driftId String @map("drift_id")

  // Execution metadata
  executedAt DateTime @default(now()) @map("executed_at")

  // Routing decision (captured at execution time)
  routingAction String @map("routing_action") // 'auto_approve', 'slack_notify', 'digest_only', 'ignore'
  confidence    Float  // Confidence score at execution time

  // Thresholds used (snapshot for reproducibility)
  thresholdsUsed Json @map("thresholds_used") // { autoApprove: 0.98, slackNotify: 0.40, ... }

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, planId])
  @@index([workspaceId, driftId])
  @@index([workspaceId, executedAt])
  @@index([workspaceId, routingAction])
  @@map("plan_runs")
}

// ======================================================================
// COVERAGE HEALTH MONITORING (Phase 3, Week 6)
// Daily snapshots of coverage metrics for monitoring and alerting
// ======================================================================

model CoverageSnapshot {
  workspaceId String   @map("workspace_id")
  id          String   @default(uuid())
  snapshotAt  DateTime @map("snapshot_at") // Timestamp of snapshot

  // Mapping Coverage Metrics
  totalServices           Int @default(0) @map("total_services") // Total unique services seen
  servicesMapped          Int @default(0) @map("services_mapped") // Services with doc mappings
  totalRepos              Int @default(0) @map("total_repos") // Total unique repos seen
  reposMapped             Int @default(0) @map("repos_mapped") // Repos with doc mappings
  mappingCoveragePercent  Float @default(0) @map("mapping_coverage_percent") // Overall mapping coverage

  // Processing Coverage Metrics
  totalSignals            Int @default(0) @map("total_signals") // Total signals in period
  signalsProcessed        Int @default(0) @map("signals_processed") // Signals that created drift candidates
  signalsIgnored          Int @default(0) @map("signals_ignored") // Signals ignored (no mapping, filtered, etc.)
  processingCoveragePercent Float @default(0) @map("processing_coverage_percent") // Signals processed / total

  // Source Health Metrics (JSON structure)
  // { "github_pr": { "total": 100, "processed": 80, "ignored": 20, "health": "good" }, ... }
  sourceHealth Json @default("{}") @map("source_health")

  // Drift Type Distribution (JSON structure)
  // { "instruction": 45, "process": 30, "ownership": 15, "coverage": 10 }
  driftTypeDistribution Json @default("{}") @map("drift_type_distribution")

  // Coverage Obligations Status (JSON structure)
  // { "mapping_coverage": { "threshold": 0.8, "actual": 0.75, "met": false }, ... }
  obligationsStatus Json @default("{}") @map("obligations_status")

  // Metadata
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, snapshotAt])
  @@map("coverage_snapshots")
}

// ======================================================================
// AUDIT TRAIL SYSTEM (Phase 4 Week 8)
// Immutable audit trail for compliance and debugging
// Renamed from AuditLog to AuditTrail to avoid conflict with legacy model
// ======================================================================

model AuditTrail {
  workspaceId String   @map("workspace_id")
  id          String   @default(uuid())
  timestamp   DateTime @default(now())

  // Event classification
  eventType   String   @map("event_type") // 'state_transition', 'evidence_created', 'plan_changed', 'approval', 'rejection', etc.
  category    String   @default("system") // 'system', 'user', 'integration', 'compliance'
  severity    String   @default("info") // 'debug', 'info', 'warning', 'error', 'critical'

  // Entity being audited
  entityType  String   @map("entity_type") // 'drift_candidate', 'patch_proposal', 'drift_plan', 'evidence_bundle', etc.
  entityId    String   @map("entity_id")

  // Actor who triggered the event
  actorType   String   @map("actor_type") // 'system', 'user', 'integration', 'agent'
  actorId     String   @map("actor_id") // User email, agent name, integration ID, etc.

  // State transition details (for drift candidates)
  fromState   String?  @map("from_state") // Previous state (if state transition)
  toState     String?  @map("to_state") // New state (if state transition)

  // Change details
  changes     Json     @default("{}") // Structured diff of what changed
  metadata    Json     @default("{}") // Additional context (error details, user input, etc.)

  // Evidence bundle tracking
  evidenceBundleHash String? @map("evidence_bundle_hash") // SHA-256 hash of evidence bundle (if applicable)
  impactBand         String? @map("impact_band") // Impact band at time of event (if applicable)

  // Plan version tracking
  planId             String? @map("plan_id") // DriftPlan ID (if applicable)
  planVersionHash    String? @map("plan_version_hash") // SHA-256 hash of plan version (if applicable)

  // Compliance flags
  requiresRetention  Boolean @default(false) @map("requires_retention") // Flag for compliance retention
  retentionUntil     DateTime? @map("retention_until") // Retention expiry date
  complianceTag      String? @map("compliance_tag") // SOX, SOC2, ISO27001, GDPR, etc.

  // Immutability - once created, never updated
  // No updatedAt field - audit trails are append-only

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([workspaceId, id])
  @@index([workspaceId, timestamp])
  @@index([workspaceId, entityType, entityId])
  @@index([workspaceId, eventType, timestamp])
  @@index([workspaceId, actorId, timestamp])
  @@index([workspaceId, category, severity, timestamp])
  @@index([evidenceBundleHash])
  @@index([planVersionHash])
  @@map("audit_trails")
}
